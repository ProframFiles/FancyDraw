#include "akjStaticResources.hpp"

// a string literal containing the contents of ..\src\shaders\WireframeShape.glsl
// made with akjToStaticString.exe

namespace akj {
	static const char* WireframeShape_glsl = 
		"\n"
		"\n"
		"// keep the two blank lines at the top so that line numbers in the debug messages\n"
		"// match up\n"
		"#define PI 3.14159265359\n"
		"\n"
		"#define PI_HALF 1.57079632679\n"
		"#define PI2 6.28318530718\n"
		"#define PI_INV 0.318309886\n"
		"\n"
		"#define SQRT2 1.41421356237\n"
		"#define HALFSQRT2 0.70710678118\n"
		"\n"
		"vec2 Perpendicular(const vec2 dir)\n"
		"{\n"
		"	return vec2(-dir.y, dir.x);\n"
		"}\n"
		"\n"
		"vec2 ShortestVecToLine(const vec2 point, const vec2 on_line, const vec2 dir)\n"
		"{\n"
		"	return abs(dot((on_line-point), Perpendicular(dir)))*(on_line-point);\n"
		"}\n"
		"\n"
		"float DistanceToLine(const vec2 point, const vec2 on_line, const vec2 dir)\n"
		"{\n"
		"	return  abs(dot((on_line-point), Perpendicular(dir)));\n"
		"}\n"
		"\n"
		"vec4 UnpackColor(uint color)\n"
		"{\n"
		"	uvec4 masks = uvec4(0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);\n"
		"	uvec4 shifts = uvec4(0, 8, 16, 24);\n"
		"	uvec4 cvec = (uvec4 (color, color, color, color) & masks) >> shifts;\n"
		"	return vec4(cvec)*vec4(0.00392157);\n"
		"}\n"
		"\n"
		"\n"
		"vec3 HueToRGB(float hue)\n"
		"{\n"
		"	vec3 s = vec3(1.0, -1.0, -1.0);\n"
		"	return sqrt(clamp(vec3(-1.0,2.0, 2.0)+s\n"
		"		*abs(vec3(3.0, 2.0, 4.0 )+vec3(-hue*6.0)), 0.0, 1.0));\n"
		"}\n"
		"\n"
		"vec4 Green(){ return vec4(0.0, 1.0, 0.0, 1.0);}\n"
		"\n"
		"// special markup for shader parsing:\n"
		"//{akj:use geometry}\n"
		"\n"
		"\n"
		"#define geometry_main main\n"
		"#define vertex_main main\n"
		"#define fragment_main main \n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Shared Uniforms\n"
		"//////////////////////////////////////////////////////////////////\n"
		"\n"
		"\n"
		"uniform mat4 uProjectionMatrix;\n"
		"uniform float uCurrentTime;\n"
		"uniform vec4 uScreenSize;\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Shared varyings\n"
		"//////////////////////////////////////////////////////////////////\n"
		"\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Vertex shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef VERTEX_SHADER\n"
		"layout(location = 0) in vec2 aTexCoord;\n"
		"layout(location = 1) in vec2 aShiftDirection;\n"
		"layout(location = 2) in vec2 aPos;\n"
		"layout(location = 3) in vec2 aShapeExtent;\n"
		"layout(location = 4) in vec4 aCornerRadius;\n"
		"layout(location = 5) in float aStrokeWidth;\n"
		"layout(location = 6) in uint aStrokeColor;\n"
		"layout(location = 7) in uint aFillColor;\n"
		"layout(location = 8) in float aDepth;\n"
		"\n"
		"noperspective out vec2 vsPos;\n"
		"flat out vec3 vsToEdge;\n"
		"flat out vec2 vsCenter;\n"
		"\n"
		"\n"
		"void vertex_main()\n"
		"{\n"
		"	vec2 texcoord = aTexCoord*aShapeExtent + aShiftDirection*vec2(aStrokeWidth+1);\n"
		"	vsToEdge = vec3(0.5);\n"
		"	vsPos = aPos+texcoord;\n"
		"	vsCenter = vsPos;\n"
		"	//world_vertex += 0.001*noise_fac;\n"
		"\n"
		"	gl_Position = uProjectionMatrix*(vec4(aPos+texcoord, 0.0, 1.0));\n"
		"}\n"
		"\n"
		"#endif\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Geometry shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef GEOMETRY_SHADER\n"
		"noperspective in vec2 vsPos[];\n"
		"flat in vec3 vsToEdge[];\n"
		"flat in vec2 vsCenter[];\n"
		"\n"
		"\n"
		"noperspective out vec2 gsPos;\n"
		"flat out vec3  gsToEdge;\n"
		"flat out vec2  gsCenter;\n"
		"\n"
		"layout (triangles) in;\n"
		"layout (triangle_strip, max_vertices=9) out;\n"
		"\n"
		"void geometry_main()\n"
		"{\n"
		"	\n"
		"	vec3 lengths = vec3(length(vsPos[1]-vsPos[2])\n"
		"											, length(vsPos[2]-vsPos[0])\n"
		"											, length(vsPos[1]-vsPos[0]) );\n"
		"\n"
		"	float inv_sum = 1.0/(lengths.x+lengths.z+ lengths.y);\n"
		"	vec2 center = (lengths.x*vsPos[0] + lengths.y*vsPos[1] + lengths.z*vsPos[2])*inv_sum;\n"
		"	vec4 glCenterPos = (lengths.x*gl_in[0].gl_Position \n"
		"											+ lengths.y*gl_in[1].gl_Position \n"
		"											+ lengths.z*gl_in[2].gl_Position)\n"
		"											* inv_sum;\n"
		"											\n"
		"	vec2 p_edge;\n"
		"	float d_line;\n"
		"\n"
		"	vec2 edge = normalize(vsPos[1] - vsPos[0]);\n"
		"	p_edge = Perpendicular(edge);\n"
		"	d_line = DistanceToLine(center, vsPos[1], edge);\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = vsPos[0];\n"
		"	gl_Position = gl_in[0].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsPos = vsPos[1];\n"
		"	gsCenter = center;\n"
		"	gl_Position = gl_in[1].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = center;\n"
		"	gl_Position = glCenterPos;\n"
		"	EmitVertex();\n"
		"	EndPrimitive();\n"
		"\n"
		"	edge = normalize(vsPos[2] - vsPos[1]);\n"
		"	p_edge = Perpendicular(edge);\n"
		"	d_line = DistanceToLine(center, vsPos[2], edge);\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = vsPos[1];\n"
		"	gl_Position = gl_in[1].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsPos = vsPos[2];\n"
		"	gsCenter = center;\n"
		"	gl_Position = gl_in[2].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = center;\n"
		"	gl_Position = glCenterPos;\n"
		"	EmitVertex();\n"
		"	EndPrimitive();\n"
		"\n"
		"	edge = normalize(vsPos[0] - vsPos[2]);\n"
		"	p_edge = Perpendicular(edge);\n"
		"	d_line = DistanceToLine(center, vsPos[0], edge);\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = vsPos[2];\n"
		"	gl_Position = gl_in[2].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsPos = vsPos[0];\n"
		"	gsCenter = center;\n"
		"	gl_Position = gl_in[0].gl_Position;\n"
		"	EmitVertex();\n"
		"\n"
		"	gsToEdge = vec3(p_edge, d_line);\n"
		"	gsCenter = center;\n"
		"	gsPos = center;\n"
		"	gl_Position = glCenterPos;\n"
		"	EmitVertex();\n"
		"	EndPrimitive();\n"
		"}\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Fragment shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#endif\n"
		"\n"
		"#ifdef FRAGMENT_SHADER\n"
		"noperspective in vec2 gsPos;\n"
		"flat in vec3 gsToEdge;\n"
		"flat in vec2 gsCenter;\n"
		"\n"
		"\n"
		"out vec4 oFragColor;\n"
		"void fragment_main()\n"
		"{	\n"
		"	// stroke edge_distance is a\n"
		"	float to_center = max(1.2-abs( abs(dot(gsToEdge.xy, gsPos - gsCenter)) - gsToEdge.z ), 0.0);\n"
		"	oFragColor = Green();\n"
		"	oFragColor.a = to_center;\n"
		"	//AlphaBlend(sc, fc);\n"
		"	//oFragColor.xyz = vec3(1.0);//HueToRGB(fract(gl_FragCoord.x));\n"
		"	//oFragColor.a = 1.0;\n"
		"}\n"
		"#endif\n";
}
