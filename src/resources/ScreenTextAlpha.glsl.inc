#include "akjStaticResources.hpp"

// a string literal containing the contents of ..\src\shaders\ScreenTextAlpha.glsl
// made with akjToStaticString.exe

namespace akj {
	static const char* ScreenTextAlpha_glsl = 
		"#define PI 3.14159265359\n"
		"#define PI2 6.28318530718\n"
		"#define PI_INV 0.318309886184\n"
		"#define SQRT2 1.41421356237\n"
		"\n"
		"vec3 GetLight(){\n"
		"	return vec3(15.0, 12.0, 30.0);\n"
		"}\n"
		"\n"
		"vec4 Red(){ return vec4(1.0, 0.0, 0.0, 1.0 );}\n"
		"vec4 Green(){ return vec4(0.0, 1.0, 0.0, 1.0 );}\n"
		"vec4 Blue(){ return vec4(0.0, 0.0, 1.0, 1.0 );}\n"
		"vec4 Yellow(){ return vec4(1.0, 1.0, 0.0, 1.0 );}\n"
		"\n"
		"float LinStep(const float bottom, const float top, const float val)\n"
		"{\n"
		"	return clamp((val-bottom)/(top-bottom),0.0, 1.0);\n"
		"}\n"
		"\n"
		"vec3 HueToRGB(float hue)\n"
		"{\n"
		"	vec3 s = vec3(1.0, -1.0, -1.0);\n"
		"	return sqrt(clamp(vec3(-1.0,2.0, 2.0)+s*abs(vec3(3.0, 2.0, 4.0 )+vec3(-hue*6.0)), 0.0, 1.0));\n"
		"}\n"
		"\n"
		"// slope is rise over run\n"
		"// we return run over rise\n"
		"float AbsSlope(const vec2 dxdy)\n"
		"{\n"
		"	vec2 abs_dxdy = abs(dxdy);\n"
		"	return  min(abs_dxdy.x, abs_dxdy.y)/max(abs_dxdy.x, abs_dxdy.y);\n"
		"}\n"
		"\n"
		"float Coverage(const float border_dis, const vec2 dxdy)\n"
		"{\n"
		"	// interpret AbsSlope as (Rise, Run). Rise is guaranteed to be bigger,\n"
		"	// so we can avoid issues with division by zero\n"
		"	float slope = AbsSlope(dxdy);\n"
		"	float angleness = dot(dxdy, vec2(1.0, 1.0));\n"
		"	float to_border = angleness*border_dis;\n"
		"	//angleness is positive when we are sampling inside the boundary (push the border forward)\n"
		"\n"
		"	// forward the end points along x by 0.5*(Run/Rise)\n"
		"	// forward the end points along x by (Run/Rise)*forward\n"
		"	vec2 ends = vec2(to_border+0.5*slope, to_border-0.5*slope);\n"
		"	float max_end = min(max(ends.x, ends.y), 0.5);\n"
		"	float min_end = max(min(ends.x, ends.y), -0.5);\n"
		"	// end ppoints are at a maximum of 0.5\n"
		"	// left area 1->max_end\n"
		"	// middle area max_end -> min_end\n"
		"	// right area min_end -> -0.5\n"
		"	float slice_height = min((max_end-min_end)/(slope+0.00001), 1.0);\n"
		"	// height of the sliced portion = max(abs(min-max)*(Rise/Run), 1.0)\n"
		"	float coverage = 1.0 - (0.5-max_end) - 0.5*(max_end-min_end)*slice_height;\n"
		"	//if angleness is negative then the rectangular portion of the sliced column is not covered\n"
		"	coverage -= (max_end-min_end)*(1.0-slice_height)*step(0.0, -angleness*(max_end-min_end));\n"
		"	return coverage;\n"
		"\n"
		"}\n"
		"\n"
		"vec4 UnpackColor(uint color)\n"
		"{\n"
		"	uvec4 masks = uvec4(0x000000FF);\n"
		"	uvec4 shifts = uvec4(0, 8, 16, 24);\n"
		"	uvec4 cvec = (uvec4 (color) >> shifts) & masks;\n"
		"	vec4 ret = vec4(cvec)*vec4(1.0/255.5);\n"
		"	return ret;\n"
		"}\n"
		"\n"
		"vec4 DebugColor()\n"
		"{\n"
		"	return vec4(1.0, 0.0, 1.0, 1.0);\n"
		"}\n"
		"vec3 rotate_by_quat(vec3 v, vec4 q)\n"
		"{\n"
		"	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w*v );\n"
		"}\n"
		"vec3 reverse_rotate_by_quat(vec3 v, vec4 q)\n"
		"{\n"
		"	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) - q.w*v );\n"
		"}\n"
		"vec3 Screen(vec3 color, vec3 light )\n"
		"{\n"
		"	return 1.0 - (1.0 - color)*(1.0 - light);\n"
		"}\n"
		"\n"
		"vec3 Overlay(vec3 color, vec3 light)\n"
		"{\n"
		"	vec3 ba = 2.0*light*color;\n"
		"	vec3 s = sign(ba-color);\n"
		"	return color+s*min(abs(ba-color), abs(2.0*Screen(color, light)-color));\n"
		"}\n"
		"vec3 Overlay(vec3 color, float light)\n"
		"{\n"
		"	return Overlay(color, vec3(light));\n"
		"}\n"
		"\n"
		"// special markup for shader parsing:\n"
		"//{akj:use geometry}\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"#define geometry_main main\n"
		"#define vertex_main main\n"
		"#define fragment_main main \n"
		"\n"
		"uniform mat4 uProjectionMatrix;\n"
		"uniform float uCurrentTime;\n"
		"\n"
		"\n"
		"#ifdef VERTEX_SHADER\n"
		"struct VertexInstance\n"
		"{\n"
		"	vec2 StringPosition;\n"
		"	vec2 Scale;\n"
		"	float StartTime;\n"
		"	float ZDepth;\n"
		"	float OuterRange;\n"
		"	float TotalTexSize;\n"
		"	uint InnerColor;\n"
		"	uint SolidColor;\n"
		"	uint OuterColor;\n"
		"	uint FontIndex;\n"
		"};\n"
		"// 48 bytes best case, 160 bytes worst case\n"
		"\n"
		"// apparently this block must be less than 16k basic machine units\n"
		"// (from GL_MAX_UNIFORM_BLOCK_SIZE) so that's capacity = 102 - 341\n"
		"\n"
		"layout(std140) uniform StringInstances\n"
		"{\n"
		"	VertexInstance uStringData[80];\n"
		"};\n"
		"\n"
		"// per vertex attributes\n"
		"layout(location = 0) in vec2 aPosition;\n"
		"layout(location = 1) in vec2 aVelocity;\n"
		"layout(location = 2) in vec2 aAccel;\n"
		"layout(location = 3) in vec2 aTexCenter;\n"
		"layout(location = 4) in vec2 aTexSize;\n"
		"layout(location = 5) in float aClockwiseRadians;\n"
		"layout(location = 6) in uint aIndex;\n"
		"\n"
		"\n"
		"#endif\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Shared Uniforms\n"
		"//////////////////////////////////////////////////////////////////\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Shared varyings\n"
		"//////////////////////////////////////////////////////////////////\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"#ifdef VERTEX_SHADER\n"
		"flat out vec2 vsRanges;\n"
		"flat out float vsStartTime;\n"
		"flat out float vsZDepth;\n"
		"flat out vec4 vsColor;\n"
		"\n"
		"// vertex specific outs\n"
		"smooth out vec2 vsCenterPos;\n"
		"smooth out vec2 vsQuadSize;\n"
		"smooth out vec2 vsTexCenter;\n"
		"smooth out vec2 vsTexSize;\n"
		"flat out vec2 vsTexPadding;\n"
		"flat out vec2 vsPosPadding;\n"
		"\n"
		"\n"
		"\n"
		"void vertex_main()\n"
		"{\n"
		"	float t = uCurrentTime- uStringData[aIndex].StartTime;\n"
		"	vec2 pos = aPosition + aVelocity*t + 0.5*(aAccel)*t*t;\n"
		"	vec2 scale = uStringData[aIndex].Scale;// *vec2((1.0+0.1*(sin(3.5*t) *sin(0.35*t))), 1.0);\n"
		"\n"
		"	vsCenterPos = uStringData[aIndex].StringPosition + pos*scale ;\n"
		"	// use for AA sample offset if desired\n"
		"	vec2 sample_offset = vec2(0.0);//(uSampleOffset/uStringData[aIndex].TotalTexSize)/ uStringData[aIndex].Scale;\n"
		"	vsTexCenter = aTexCenter + sample_offset;\n"
		"	vsTexSize = aTexSize;\n"
		"	vsQuadSize = aTexSize*scale;\n"
		"	vsPosPadding = uStringData[aIndex].OuterRange*scale;\n"
		"	vsTexPadding = vec2(uStringData[aIndex].OuterRange);\n"
		"	vsZDepth = uStringData[aIndex].ZDepth;\n"
		"	vsStartTime = uStringData[aIndex].StartTime;\n"
		"	float fuzz_range = 1.0/(scale.x*uStringData[aIndex].OuterRange);\n"
		"	vsRanges.x = fuzz_range*uStringData[aIndex].TotalTexSize;\n"
		"	vsRanges.y = 1.0/uStringData[aIndex].OuterRange;\n"
		"\n"
		"	vsColor = UnpackColor(uStringData[aIndex].SolidColor);\n"
		"\n"
		"}\n"
		"#endif\n"
		"\n"
		"#ifdef GEOMETRY_SHADER\n"
		"flat in vec2 vsRanges[];\n"
		"flat in float vsStartTime[];\n"
		"flat in float vsZDepth[];\n"
		"flat in vec4 vsColor[];\n"
		"\n"
		"// vertex specific outs\n"
		"smooth in vec2 vsCenterPos[];\n"
		"smooth in vec2 vsQuadSize[];\n"
		"smooth in vec2 vsTexCenter[];\n"
		"smooth in vec2 vsTexSize[];\n"
		"flat in vec2 vsTexPadding[];\n"
		"flat in vec2 vsPosPadding[];\n"
		"\n"
		"smooth out vec2 gsTexCoord;\n"
		"flat out vec2 gsRanges;\n"
		"flat out float gsStartTime;\n"
		"flat out float gsZDepth;\n"
		"flat out vec4 gsColor;\n"
		"\n"
		"layout(points) in;\n"
		"layout(triangle_strip, max_vertices=4) out;\n"
		"\n"
		"void geometry_main()\n"
		"{\n"
		"	// emit from left to right:  UL -> UR -> LL -> LR\n"
		"\n"
		"	gsRanges = vsRanges[0];\n"
		"	gsStartTime = vsStartTime[0];\n"
		"	vec2 pos;\n"
		"	vec2 dir;\n"
		"	vec2 pos_snap = vec2(0.0, 0.0);\n"
		"	vec2 pos_to_tex = vec2(1.0, -1.0)*(vsTexPadding[0]/vsPosPadding[0]);\n"
		"\n"
		"	dir = vec2(-1.0, -1.0);\n"
		"	gsTexCoord = vsTexCenter[0] + vec2(0.0, -1.0)*vsTexSize[0] + dir*vec2(1.0, 1.0)*vsTexPadding[0];\n"
		"	pos =  vsCenterPos[0]+vec2(0.0, -1.0)*vsQuadSize[0] + dir*vsPosPadding[0];\n"
		"\n"
		"	gl_Position = uProjectionMatrix*(vec4(pos, -0.1, 1.0));\n"
		"	gsZDepth = vsZDepth[0];\n"
		"	gsColor = vsColor[0];\n"
		"	EmitVertex();\n"
		"	\n"
		"	gsRanges = vsRanges[0];\n"
		"	gsStartTime = vsStartTime[0];\n"
		"\n"
		"	dir = vec2(1.0, -1.0);\n"
		"	gsTexCoord = vsTexCenter[0] + vec2(1.0, -1.0)*vsTexSize[0]+ dir*vec2(1.0, 1.0)*vsTexPadding[0];\n"
		"	pos = vsCenterPos[0]+vec2(1.0, -1.0)*vsQuadSize[0] + dir*vsPosPadding[0];\n"
		"\n"
		"	gl_Position = uProjectionMatrix*(vec4(pos, -0.1, 1.0));\n"
		"	gsZDepth = vsZDepth[0];\n"
		"	gsColor = vsColor[0];\n"
		"	EmitVertex();\n"
		"\n"
		"	gsRanges = vsRanges[0];\n"
		"	gsStartTime = vsStartTime[0];\n"
		"\n"
		"	dir = vec2(-1.0, 1.0);\n"
		"	gsTexCoord = vsTexCenter[0] + vec2(0.0, 0.0)*vsTexSize[0]+ dir*vec2(1.0, 1.0)*vsTexPadding[0];\n"
		"	pos = vsCenterPos[0]+vec2(0.0, 0.0)*vsQuadSize[0] + dir*vsPosPadding[0];\n"
		"	gl_Position = uProjectionMatrix*(vec4(pos, -0.1, 1.0));\n"
		"	gsZDepth = vsZDepth[0];\n"
		"	gsColor = vsColor[0];\n"
		"	EmitVertex();\n"
		"\n"
		"	gsRanges = vsRanges[0];\n"
		"	gsStartTime = vsStartTime[0];\n"
		"\n"
		"	dir = vec2(1.0, 1.0);\n"
		"	gsTexCoord = vsTexCenter[0] + vec2(1.0, 0.0)*vsTexSize[0] + dir*vec2(1.0, 1.0)*vsTexPadding[0];\n"
		"	pos = vsCenterPos[0]+vec2(1.0, 0.0)*vsQuadSize[0] + dir*vsPosPadding[0];\n"
		"	gl_Position = uProjectionMatrix*(vec4(pos, -0.1, 1.0));\n"
		"	gsZDepth = vsZDepth[0];\n"
		"	gsColor = vsColor[0];\n"
		"	EmitVertex();\n"
		"	EndPrimitive();\n"
		"}\n"
		"#endif\n"
		"\n"
		"#ifdef FRAGMENT_SHADER\n"
		"flat in vec2 gsRanges;\n"
		"flat in float gsStartTime;\n"
		"flat in float gsZDepth;\n"
		"flat in vec4 gsColor;\n"
		"\n"
		"uniform float uDirectProportion;\n"
		"uniform float uAlpha;\n"
		"\n"
		"\n"
		"layout(origin_upper_left) in vec4 gl_FragCoord;\n"
		"\n"
		"smooth in vec2 gsTexCoord;\n"
		"\n"
		"uniform sampler2D uFontTexture;\n"
		"\n"
		"uniform vec2 uFudgeFactors;\n"
		"\n"
		"out vec4 oFragColor;\n"
		"\n"
		"\n"
		"vec4 SampleBilinear(const vec2 tex_coord)\n"
		"{\n"
		"	vec2 f_index = tex_coord-vec2(0.5); \n"
		"	ivec2 icoord = ivec2(floor(tex_coord));\n"
		"	ivec2 incr = ivec2(ceil(f_index)) - icoord;\n"
		"	ivec2 decr = ivec2(ivec2(floor(f_index)) - icoord);\n"
		"	vec2 incr_weights = 1.0-(icoord+0.5+incr-tex_coord);\n"
		"	vec2 decr_weights = 1.0-incr_weights;\n"
		"	vec4 ret = (incr_weights.x)*incr_weights.y\n"
		"							*texelFetch(uFontTexture,icoord+ivec2(1,0)*incr+ivec2(0,1)*incr, 0);\n"
		"	ret += (incr_weights.x)*decr_weights.y\n"
		"							*texelFetch(uFontTexture,icoord+ivec2(1,0)*incr+ivec2(0,1)*decr, 0);\n"
		"	ret += (decr_weights.x)*incr_weights.y\n"
		"							*texelFetch(uFontTexture,icoord+ivec2(1,0)*decr+ivec2(0,1)*incr, 0);\n"
		"	ret += (decr_weights.x)*decr_weights.y\n"
		"							*texelFetch(uFontTexture,icoord+ivec2(1,0)*decr+ivec2(0,1)*decr, 0);\n"
		"	return ret;\n"
		"}\n"
		"\n"
		"vec4 SampleNearest(const vec2 tex_coord)\n"
		"{\n"
		"	return 	vec4(texelFetch(uFontTexture, ivec2(floor(tex_coord)), 0));\n"
		"}\n"
		"\n"
		"float RenderTexDirect(const vec2 tex_coord)\n"
		"{\n"
		"	return 1.0-texelFetch(uFontTexture, ivec2(floor(tex_coord)), 0).r;\n"
		"}\n"
		"\n"
		"float RenderDistanceField(const vec2 tex_coord)\n"
		"{\n"
		"	vec4 samp = SampleBilinear(tex_coord);//texture2D(uFontTexture, gsTexCoord);\n"
		"	float edge_shift = uFudgeFactors.x;\n"
		"	//float h2 = uFudgeFactors.y*((1.0*(abs(samp.b-0.5)+abs( samp.g-0.5))/gsRanges.x) +edge_shift);\n"
		"	float h = uFudgeFactors.y*(((0.5-samp.r)/gsRanges.x) +edge_shift);\n"
		"	vec2 dsamp = abs(normalize(vec2(samp.g-0.5, samp.b-0.5)));\n"
		"	//float edge = step(middle, h);\n"
		"	//return LinStep(0.0, 1.0, Coverage( abs(h), sign(h)*dsamp));\n"
		"	return LinStep(-0.5, 0.5, h);\n"
		"}\n"
		"\n"
		"\n"
		"void fragment_main()\n"
		"{\n"
		"	float edge = mix(RenderDistanceField(gsTexCoord), RenderTexDirect(gsTexCoord), uDirectProportion);\n"
		"	//float edge = LinStep(-0.5, 0.5, h);\n"
		"	//float inner_portion = step(1.0-gsRanges.x*0.45-gsRanges.y,  (1.0 - samp));\n"
		"	//float mult = step(-0.5, inner_portion);\n"
		"	//float mult = samp.a*step(0.00001, edge);\n"
		"	oFragColor = gsColor;\n"
		"	//oFragColor.r = 1.0-2.0*length(vec2(samp.b-0.5, samp.g-0.5));\n"
		"	oFragColor.a *= pow(edge, 1.4);//(clamp(max(Coverage(h+0.0, dsamp), h), 0, 1))*mult;\n"
		"	// we blend using blend_max, so this has to be inverted\n"
		"	// if we have non-0 coverage, then the depth is gsZdepth\n"
		"	// oFragColor.g = mix(0.0, 1.0-gsZDepth, mult);\n"
		"}\n"
		"#endif\n";
}
