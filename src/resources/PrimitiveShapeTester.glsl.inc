#include "akjStaticResources.hpp"

// a string literal containing the contents of ..\src\shaders\PrimitiveShapeTester.glsl
// made with akjToStaticString.exe

namespace akj {
	static const char* PrimitiveShapeTester_glsl = 
		"#define PI 3.14159265359\n"
		"#define PI_HALF 1.57079632679\n"
		"#define PI2 6.28318530718\n"
		"#define PI_INV 0.318309886184\n"
		"#define SQRT2 1.41421356237\n"
		"\n"
		"\n"
		"vec4 UnpackColor(uint color)\n"
		"{\n"
		"	uvec4 masks = uvec4(0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);\n"
		"	uvec4 shifts = uvec4(0, 8, 16, 24);\n"
		"	uvec4 cvec = (uvec4 (color, color, color, color) & masks) >> shifts;\n"
		"	return vec4(cvec)*vec4(0.00392157);\n"
		"}\n"
		"\n"
		"vec4 AlphaBlend(vec4 top, vec4 bottom)\n"
		"{\n"
		"	float max_a = max(top.a, bottom.a);\n"
		"	return vec4(mix(top.rgb, bottom.rgb, (max_a- top.a)/max_a ), max_a);\n"
		"}\n"
		"\n"
		"float LinOsc(const float angle)\n"
		"{\n"
		"	return 2.0*abs(0.5-fract(angle));\n"
		"}\n"
		"\n"
		"float NSin(const float angle)\n"
		"{\n"
		"	return 0.5*sin(angle)+0.5;\n"
		"}\n"
		"\n"
		"//0 == red, 1.0 == red\n"
		"vec3 HueToRGB(float hue)\n"
		"{\n"
		"	vec3 s = vec3(1.0, -1.0, -1.0);\n"
		"	return sqrt(clamp(vec3(-1.0,2.0, 2.0)+s*abs(vec3(3.0, 2.0, 4.0 )+vec3(-hue*6.0)), 0.0, 1.0));\n"
		"}\n"
		"\n"
		"// the first coord returned is the distance to the stroke line\n"
		"// the second ditnce returned is the distance from the fill area\n"
		"vec2 EdgeDistance(const vec2 pos,const vec2 edge, const float radius)\n"
		"{\n"
		"	// pretend we have a point outside the box\n"
		"	// edge: (20, 20) , pos = (23, 20)\n"
		"	// to_edge = -3, 0\n"
		"	// abs_edge_vec = (3, 0)\n"
		"	// abs_edge_d = 0\n"
		"	// outside_edge_distance = 3\n"
		"	// abs_edge_d = 3\n"
		"\n"
		"	// pretend we have a point inside the box\n"
		"	// edge: (20, 20) , pos = (5, 5)\n"
		"	// to_edge = 15, 15\n"
		"	// abs_edge_vec = (15, 15)\n"
		"	// abs_edge_d = 15\n"
		"	// outside_edge_distance = 0\n"
		"	// abs_edge_d = 15\n"
		"\n"
		"	vec2 to_edge = edge - pos ;\n"
		"	vec2 abs_edge_vec = abs(to_edge);\n"
		"	float abs_edge_d = min(abs_edge_vec.x, abs_edge_vec.y);\n"
		"	float outside_edge_distance = min(to_edge.x, to_edge.y);\n"
		"	\n"
		"	//TODO: fix this\n"
		"	to_edge -= radius;\n"
		"	// to edge has the distance to the corner (negative means outside)\n"
		"	// if both directions are outside, then we want to limit things\n"
		"	float r = radius-distance(pos, edge-vec2(radius));\n"
		"	float r_mix = step(0.0, -max(to_edge.x, to_edge.y));\n"
		"	// if r is 0, then we should ignore it, otherwise it replaces abs_edge\n"
		"	outside_edge_distance = -min(mix(outside_edge_distance, r, r_mix), 0);\n"
		"	abs_edge_d = max(mix( abs_edge_d,abs(r), r_mix), outside_edge_distance);\n"
		"	//abs_edge_d = max(abs_edge_d, outside_edge_distance);\n"
		"\n"
		"	// we have to be limited by the distance beyond the edge\n"
		"	return vec2(abs_edge_d, outside_edge_distance);\n"
		"\n"
		"}\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Vertex shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef VERTEX_SHADER\n"
		"layout(location = 0) in vec2 aTexCoord;\n"
		"layout(location = 1) in vec2 aShiftDirection;\n"
		"layout(location = 2) in vec2 aPos;\n"
		"layout(location = 3) in vec2 aShapeExtent;\n"
		"layout(location = 4) in float aCornerRadius;\n"
		"layout(location = 5) in float aStrokeWidth;\n"
		"layout(location = 6) in uint aStrokeColor;\n"
		"layout(location = 7) in uint aFillColor;\n"
		"layout(location = 8) in vec2 aExtra;\n"
		"\n"
		"uniform mat4 uProjectionMatrix;\n"
		"#endif\n"
		"\n"
		"\n"
		"#ifdef FRAGMENT_SHADER\n"
		"#define INOUT centroid in\n"
		"#else \n"
		"#define INOUT centroid out\n"
		"#endif\n"
		"\n"
		"noperspective INOUT vec2 vTexCoord;\n"
		"noperspective INOUT vec2 vShapeExtent;\n"
		"noperspective INOUT vec2 vPos;\n"
		"flat INOUT float vCornerRadius;\n"
		"flat INOUT float vStrokeWidth;\n"
		"flat INOUT vec4 vStrokeColor;\n"
		"flat INOUT vec4 vFillColor;\n"
		"\n"
		"\n"
		"uniform float uCurrentTime;\n"
		"uniform vec2 uMousePos;\n"
		"\n"
		"#ifdef VERTEX_SHADER\n"
		"void main()\n"
		"{\n"
		"	vTexCoord = aTexCoord*aShapeExtent + aShiftDirection*vec2(aStrokeWidth*0.5);\n"
		"	\n"
		"	vShapeExtent = abs(aShapeExtent);\n"
		"	vCornerRadius = aCornerRadius;\n"
		"	vStrokeWidth = aStrokeWidth;\n"
		"	vStrokeColor = UnpackColor(aStrokeColor);\n"
		"	vFillColor = UnpackColor(aFillColor);\n"
		"	\n"
		"	vPos = aPos+vTexCoord;\n"
		"	//vPos.x += LinOsc(uCurrentTime);\n"
		"	gl_Position = uProjectionMatrix*(vec4(vPos, -0.001*gl_InstanceID, 1.0));\n"
		"}\n"
		"#endif\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Fragment shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef FRAGMENT_SHADER\n"
		"//layout(origin_upper_left)\n"
		" in vec4 gl_FragCoord;\n"
		"out vec4 oFragColor;\n"
		"\n"
		"void main()\n"
		"{	\n"
		"	float x_dist = (vShapeExtent.x - abs(vTexCoord.x));\n"
		"	float is_fractional = step(0, 1.0-x_dist);\n"
		"	oFragColor.g = gl_FragCoord.x;\n"
		"	oFragColor.b = vPos.x;\n"
		"	oFragColor.r = vTexCoord.x;\n"
		"	oFragColor.a = 1.0;\n"
		"}\n"
		"#endif\n";
}
