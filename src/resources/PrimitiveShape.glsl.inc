#include "akjStaticResources.hpp"

// a string literal containing the contents of ..\src\shaders\PrimitiveShape.glsl
// made with akjToStaticString.exe

namespace akj {
	static const char* PrimitiveShape_glsl = 
		"\n"
		"\n"
		"#define PI 3.14159265359\n"
		"#define PI_HALF 1.57079632679\n"
		"#define PI2 6.28318530718\n"
		"#define PI_INV 0.318309886184\n"
		"#define SQRT2 1.41421356237\n"
		"#define HALFSQRT2 0.707106781186548\n"
		"\n"
		"\n"
		"vec4 UnpackColor(uint color)\n"
		"{\n"
		"	uvec4 masks = uvec4(0x000000FF);\n"
		"	uvec4 shifts = uvec4(0, 8, 16, 24);\n"
		"	uvec4 cvec = (uvec4 (color) >> shifts) & masks;\n"
		"	vec4 ret = vec4(cvec)*vec4(1.0/255.5);\n"
		"	return ret;\n"
		"}\n"
		"\n"
		"vec4 AlphaBlend(vec4 top, vec4 bottom)\n"
		"{\n"
		"	float max_a = max(top.a, bottom.a);\n"
		"	return vec4(mix(top.rgb, bottom.rgb, (max_a- top.a)/max_a ), max_a);\n"
		"}\n"
		"\n"
		"\n"
		"vec3 HueToRGB(float hue)\n"
		"{\n"
		"	vec3 s = vec3(1.0, -1.0, -1.0);\n"
		"	return sqrt(clamp(vec3(-1.0,2.0, 2.0)+s*abs(vec3(3.0, 2.0, 4.0 )+vec3(-hue*6.0)), 0.0, 1.0));\n"
		"}\n"
		"\n"
		"vec4 DistanceToEdge(const vec2 pos,const vec2 point,const float radius)\n"
		"{\n"
		"	vec2 radial_corner = point - vec2(radius);\n"
		"	vec2 radial_vec = pos-radial_corner;\n"
		"	bool has_radial_bound = all(greaterThan(radial_vec, vec2(0.0)));\n"
		"	float radial_length = length(radial_vec);\n"
		"	\n"
		"	vec2 man_dist = (point-pos);\n"
		"	float manhattan_distance = min(man_dist.x, man_dist.y);\n"
		"	float radial_distance = mix(manhattan_distance,(radius - radial_length), has_radial_bound) ;\n"
		"	float fuzz_dist = mix(1.0, sqrt(abs(dot(radial_vec/radial_length, vec2(1.0, 1.0)))), has_radial_bound);\n"
		"	return vec4( radial_distance, fuzz_dist, fuzz_dist-1.0, 1.0/fuzz_dist);\n"
		"}		\n"
		"\n"
		"// the first coord returned is the distance to the stroke line\n"
		"// the second ditnce returned is the distance from the fill area\n"
		"vec2 EdgeDistance(const vec2 pos,const vec2 edge, const float radius)\n"
		"{\n"
		"	\n"
		"\n"
		"	vec2 to_edge = edge - pos ;\n"
		"	vec2 abs_edge_vec = abs(to_edge);\n"
		"	float abs_edge_d = min(abs_edge_vec.x, abs_edge_vec.y);\n"
		"	float outside_edge_distance = min(to_edge.x, to_edge.y);\n"
		"	\n"
		"	//TODO: fix this\n"
		"	to_edge -= radius;\n"
		"	// to edge has the distance to the corner (negative means outside)\n"
		"	// if both directions are outside, then we want to limit things\n"
		"	float r = radius-distance(pos, edge-vec2(radius));\n"
		"	float r_mix = step(0.0, -max(to_edge.x, to_edge.y));\n"
		"	// if r is 0, then we should ignore it, otherwise it replaces abs_edge\n"
		"	outside_edge_distance = -min(mix(outside_edge_distance, r, r_mix), 0);\n"
		"	abs_edge_d = max(mix( abs_edge_d,abs(r), r_mix), outside_edge_distance);\n"
		"	//abs_edge_d = max(abs_edge_d, outside_edge_distance);\n"
		"\n"
		"	// we have to be limited by the distance beyond the edge\n"
		"	return vec2(abs_edge_d, outside_edge_distance);\n"
		"\n"
		"}\n"
		"\n"
		"#ifdef FRAGMENT_SHADER\n"
		"#define INOUT in\n"
		"#else \n"
		"#define INOUT out\n"
		"#endif\n"
		"\n"
		"centroid INOUT vec2 vTexCoord;\n"
		"centroid INOUT vec2 vShapeExtent;\n"
		"flat INOUT float vCornerRadius;\n"
		"flat INOUT float vStrokeWidth;\n"
		"flat INOUT float vDepth;\n"
		"flat INOUT float vInverseStrokeAlpha;\n"
		"flat INOUT vec4 vStrokeColor;\n"
		"flat INOUT vec4 vFillColor;\n"
		"flat INOUT vec2 vFillTexOffset;\n"
		"flat INOUT float vFillTexMix;\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Vertex shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef VERTEX_SHADER\n"
		"layout(location = 0) in vec2 aTexCoord;\n"
		"layout(location = 1) in vec2 aShiftDirection;\n"
		"layout(location = 2) in vec2 aPos;\n"
		"layout(location = 3) in vec2 aShapeExtent;\n"
		"layout(location = 4) in float aCornerRadius;\n"
		"layout(location = 5) in float aStrokeWidth;\n"
		"layout(location = 6) in uint aStrokeColor;\n"
		"layout(location = 7) in uint aFillColor;\n"
		"layout(location = 9) in vec2 aFillCoord;\n"
		"layout(location = 8) in float aDepth;\n"
		"layout(location = 10) in float aExtraFillAlpha;\n"
		"\n"
		"uniform mat4 uProjectionMatrix;\n"
		"uniform float uCurrentTime;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	vTexCoord = aTexCoord*aShapeExtent + aShiftDirection*vec2(aStrokeWidth+2);\n"
		"	vShapeExtent = aShapeExtent;\n"
		"	vCornerRadius = aCornerRadius;\n"
		"	vStrokeWidth = aStrokeWidth;\n"
		"	vStrokeColor = UnpackColor(aStrokeColor);\n"
		"	vFillColor = UnpackColor(aFillColor);\n"
		"	vInverseStrokeAlpha = 1.0/vStrokeColor.a;\n"
		"	vDepth = aDepth;\n"
		"	//world_vertex += 0.001*noise_fac;\n"
		"	gl_Position = uProjectionMatrix*(vec4(aPos+vTexCoord, 0.0, 1.0));\n"
		"}\n"
		"#endif\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"//////////////////////////////////////////////////////////////////\n"
		"// Fragment shader only\n"
		"//////////////////////////////////////////////////////////////////\n"
		"#ifdef FRAGMENT_SHADER\n"
		"layout(origin_upper_left) in vec4 gl_FragCoord;\n"
		"uniform float uCurrentTime;\n"
		"\n"
		"out vec4 oFragColor;\n"
		"out float gl_FragDepth;\n"
		"void main()\n"
		"{	\n"
		"	// stroke edge_distance is a \n"
		"	vec4 ed = DistanceToEdge(abs(vTexCoord), vShapeExtent, vCornerRadius);\n"
		"	vec4 sc = vStrokeColor;\n"
		"	sc.a *= mix(0.0, 1.0, clamp(vStrokeWidth+1.0-abs(ed.x)+ed.z, 0, ed.y)*ed.w);\n"
		"	vec4 fc = vFillColor;\n"
		"	fc.a *= mix(0.0, 1.0, clamp(1 + ed.x+ed.z, 0, ed.y)*ed.w);\n"
		"	oFragColor = AlphaBlend(sc, fc);\n"
		"	gl_FragDepth = mix(1.0, vDepth, oFragColor.a > 0.001);\n"
		"	//AlphaBlend(sc, fc);\n"
		"	//oFragColor.xyz = vec3(1.0);//HueToRGB(fract(gl_FragCoord.x));\n"
		"	//oFragColor.a = 1.0;\n"
		"}\n"
		"#endif\n";
}
